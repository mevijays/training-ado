In an enterprise environment, relying on Personal Access Tokens (PATs) is indeed a security risk because they are tied to a specific user's identity and life cycle. If that user leaves the company or their permissions change, the pipeline breaks.

The enterprise-standard way to handle this is by using the **Project Collection Build Service** identity. This is a built-in "service identity" that Azure DevOps provides to every pipeline automatically.

### 1. The Secure Enterprise Approach: `System.AccessToken`

Instead of a PAT, you use the **`$(System.AccessToken)`**. This is a dynamic, short-lived token generated by Azure DevOps specifically for the duration of that single pipeline run.

#### **Step A: Grant Permissions to the Build Service**

Before running the pipeline, you must ensure the build identity has permission to "Push" to your feed:

1. Go to **Artifacts** -> Select your feed -> Click the **Gear icon (Feed Settings)**.
2. Select **Permissions**.
3. Ensure **`[Project Name] Build Service ([Org Name])`** is added with the role **Contributor** (or "Feed Publisher").
4. In case the build service user is not available search it and add to give publisher permission. **NOTE** Search name as your project name.

---

### 2. The Implementation (YAML)

You can use the `MavenAuthenticate@0` task, which is the cleanest way to handle enterprise auth. It automatically configures the Maven `settings.xml` on the build agent to use the system's identity.

```yaml
trigger:
- main

pool:
  vmImage: 'ubuntu-latest'

steps:
- checkout: self

# This task finds your feeds and injects the $(System.AccessToken) 
# into the agent's Maven settings.xml automatically.
- task: MavenAuthenticate@0
  displayName: 'Maven Authenticate'
  inputs:
    artifactsFeeds: 'YourFeedName' # Just the name, not the URL

- task: Maven@4
  displayName: 'Maven Build and Deploy'
  inputs:
    mavenPomFile: 'pom.xml'
    goals: 'deploy'
    publishJUnitResults: true
    javaHomeOption: 'JDKVersion'
    jdkVersionOption: '1.17'

```

---

### 3. Manual Configuration (The "Zero-Task" Method)

If you prefer to control the `settings.xml` manually (e.g., if you are using a custom shell script instead of the Maven task), you can reference the environment variable directly.

**In your `settings.xml` (committed to repo or created on the fly):**

```xml
<server>
  <id>YourFeedName</id>
  <username>$(ProjectName)</username>
  <password>${env.SYSTEM_ACCESSTOKEN}</password>
</server>

```

**In your YAML, you must explicitly map the token to the environment:**

```yaml
- script: mvn deploy -s $(Build.SourcesDirectory)/settings.xml
  env:
    # This maps the secret system token to an environment variable 
    # so Maven can read it.
    SYSTEM_ACCESSTOKEN: $(System.AccessToken)

```
**NOTE: use either of one method. mavenauthenticatetask or settings.xml. If using maven authenticate then no -s settings.xml**
---

### Comparison of Methods

| Method | Best For | Security Level |
| --- | --- | --- |
| **PAT** | Personal/Local testing | **Low** (Tied to user, long-lived) |
| **MavenAuthenticate Task** | Standard Enterprise Pipelines | **High** (Dynamic, no manual secrets) |
| **System.AccessToken** | Custom scripts/Complex builds | **High** (Short-lived, scoped to job) |

